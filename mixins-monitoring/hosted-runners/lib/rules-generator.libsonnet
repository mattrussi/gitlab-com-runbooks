local recordingRules = import 'recording-rules/recording-rules.libsonnet';
local intervalForDuration = import 'servicemetrics/interval-for-duration.libsonnet';
local recordingRuleRegistry = import 'servicemetrics/recording-rule-registry.libsonnet';
local saturationRules = import 'servicemetrics/saturation_rules.libsonnet';

local generatorsForService(aggregationSet, burnRate, extraSelector) = [
  recordingRules.componentMetricsRuleSetGenerator(
    burnRate=burnRate,
    aggregationSet=aggregationSet,
    extraSourceSelector=extraSelector,
    config={ recordingRuleRegistry: recordingRuleRegistry.nullRegistry },
  ),
];

local groupsForService(service, aggregationSet, extraSelector={}) =
  std.map(
    function(burnRate)
      local rules = std.flatMap(
        function(generator)
          generator.generateRecordingRulesForService(service),
        generatorsForService(aggregationSet, burnRate, extraSelector)
      );

      if std.length(rules) > 0 then
        {
          name: '%s: %s - Burn-Rate %s' % [aggregationSet.name, service.type, burnRate],
          interval: intervalForDuration.intervalForDuration(burnRate),
          rules: rules,
        }
      else {},
    aggregationSet.getBurnRates(),
  );

local aggregationsForService(service, aggregationSets) =
  std.foldl(
    function(memo, set)
      local groups = std.prune(groupsForService(service, set));
      memo + groups,
    std.objectValues(aggregationSets),
    []
  );

local saturationGroup(saturationResource) =
  saturationRules.generateSaturationRulesGroup(
    evaluation='both',
    saturationResources=saturationResource,
    thanosSelfMonitoring=false,
    extraSourceSelector={}
  );

local serviceSLOsGroups(service) =
  local serviceSLOsRulesetGenerator = recordingRules.serviceSLORuleSetGenerator();
  local serviceMappingRulesetGenerator = recordingRules.serviceMappingRuleSetGenerator();

  [{
    name: 'Autogenerated Service SLOs',
    interval: '5m',
    rules:
      std.flattenArrays([
        serviceSLOsRulesetGenerator.generateRecordingRulesForService(service),
        serviceMappingRulesetGenerator.generateRecordingRulesForService(service)
      ])
  }];

local componentMapping(service) =
  local componentMappingRuleSetGenerator = recordingRules.componentMappingRuleSetGenerator();

  [{
      name: 'Component mapping: %s' % [service.type],
      interval: '1m',
      rules: componentMappingRuleSetGenerator.generateRecordingRulesForService(service),
  }];

local aggregationRulesForService(config) =
  local saturationResource = config.gitlabMetricsConfig.saturationMonitoring;
  local aggregationSets = config.gitlabMetricsConfig.aggregationSets;

  std.flattenArrays([
    saturationGroup(saturationResource),
    std.foldl(
      function(memo, service)
        memo +
        aggregationsForService(service, aggregationSets) +
        serviceSLOsGroups(service) +
        componentMapping(service),
      config.gitlabMetricsConfig.monitoredServices,
      []
    )
  ]);

aggregationRulesForService
